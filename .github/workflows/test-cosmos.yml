name: Test Azure Cosmos DB (Fixed)

on:
  workflow_dispatch:
    inputs:
      test_data_count:
        description: 'Number of test records to create'
        required: false
        default: '10'
        type: string

env:
  # Only need the connection string for Node.js SDK
  AZURE_COSMOSDB_CONNECTION_STRING: ${{ secrets.AZURE_COSMOSDB_CONNECTION_STRING }}
  TEST_CONTAINER_NAME: "test-pen-records"
  TEST_DATABASE_NAME: "test-pen-database"

jobs:
  test-cosmos-db:
    runs-on: ubuntu-latest
    environment: dev
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install dependencies
      run: |
        echo "Installing Azure Cosmos DB SDK..."
        npm init -y
        # Install specific version of uuid that supports CommonJS or use crypto for UUID generation
        npm install @azure/cosmos
        echo "Dependencies installed successfully"

    - name: Validate Configuration
      run: |
        echo "Validating Cosmos DB configuration..."
        if [ -z "$AZURE_COSMOSDB_CONNECTION_STRING" ]; then
          echo "‚ùå AZURE_COSMOSDB_CONNECTION_STRING is not set"
          echo "Please add this secret to your GitHub repository"
          exit 1
        fi
        
        # Extract endpoint from connection string for validation
        if [[ "$AZURE_COSMOSDB_CONNECTION_STRING" =~ AccountEndpoint=([^;]+) ]]; then
          ENDPOINT="${BASH_REMATCH[1]}"
          echo "‚úÖ Found endpoint in connection string: $ENDPOINT"
        else
          echo "‚ùå Invalid connection string format"
          exit 1
        fi

    - name: Test Connection and Create Resources
      run: |
        echo "Testing Cosmos DB connection and creating test resources..."
        
        cat > test-cosmos-complete.js << 'EOF'
        const { CosmosClient } = require('@azure/cosmos');
        const crypto = require('crypto');
        
        // Generate UUID using Node.js built-in crypto module
        function generateUUID() {
          return crypto.randomUUID();
        }
        
        async function testCosmosDB() {
          try {
            console.log('üîó Connecting to Cosmos DB...');
            
            // Create client using connection string with enhanced configuration
            const client = new CosmosClient({
              connectionString: process.env.AZURE_COSMOSDB_CONNECTION_STRING,
              connectionPolicy: {
                requestTimeout: 30000,
                retryOptions: {
                  maxRetryAttemptCount: 3,
                  fixedRetryIntervalInMilliseconds: 2000,
                  maxWaitTimeInSeconds: 60
                }
              }
            });
            
            // Test connection by listing databases
            console.log('üìã Testing connection...');
            const { resources: databases } = await client.databases.readAll().fetchAll();
            console.log(`‚úÖ Connected successfully! Found ${databases.length} existing databases`);
            
            // Create test database
            console.log('üì¶ Creating test database...');
            const { database } = await client.databases.createIfNotExists({
              id: process.env.TEST_DATABASE_NAME,
              throughput: 400
            });
            console.log(`‚úÖ Database ready: ${database.id}`);
            
            // Create test container with optimized settings
            console.log('üìã Creating test container...');
            const containerDef = {
              id: process.env.TEST_CONTAINER_NAME,
              partitionKey: {
                paths: ['/pen'],
                kind: 'Hash'
              },
              indexingPolicy: {
                indexingMode: 'consistent',
                automatic: true,
                includedPaths: [
                  { path: '/*' }
                ],
                excludedPaths: [
                  { path: '/"_etag"/?' },
                  { path: '/"_attachments"/?' },
                  { path: '/"_ts"/?' }
                ],
                compositeIndexes: [
                  [
                    { path: '/legalLastName', order: 'ascending' },
                    { path: '/legalFirstName', order: 'ascending' }
                  ],
                  [
                    { path: '/dob', order: 'descending' },
                    { path: '/pen', order: 'ascending' }
                  ]
                ]
              },
              uniqueKeyPolicy: {
                uniqueKeys: [
                  { paths: ['/pen'] }
                ]
              }
            };
            
            const { container } = await database.containers.createIfNotExists(containerDef);
            console.log(`‚úÖ Container ready: ${container.id}`);
            
            // Test data operations
            console.log('üíæ Testing data operations...');
            
            // Create test record
            const testRecord = {
              id: generateUUID(),
              pen: 'TEST001',
              legalFirstName: 'John',
              legalMiddleNames: 'Test',
              legalLastName: 'Doe',
              dob: '1990-01-01',
              localID: 'LOCAL001',
              createdAt: new Date().toISOString(),
              testRecord: true,
              _partitionKey: 'TEST001' // Explicit partition key for clarity
            };
            
            // Insert record
            console.log('   Creating initial test record...');
            const { resource: created } = await container.items.create(testRecord);
            console.log(`‚úÖ Record created with ID: ${created.id}`);
            
            // Read record
            console.log('   Reading test record...');
            const { resource: read } = await container.item(created.id, 'TEST001').read();
            console.log(`‚úÖ Record read: ${read.legalFirstName} ${read.legalLastName}`);
            
            // Query records
            console.log('   Querying test records...');
            const { resources: queryResults } = await container.items
              .query('SELECT * FROM c WHERE c.testRecord = true')
              .fetchAll();
            console.log(`‚úÖ Query found ${queryResults.length} test records`);
            
            // Generate and insert multiple test records
            const testCount = parseInt(process.env.TEST_DATA_COUNT || '5');
            console.log(`üìù Generating ${testCount} additional test records...`);
            
            const names = {
              first: ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace', 'Henry', 'Ivy', 'Jack'],
              last: ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez'],
              middle: ['Ann', 'Lee', 'Ray', 'May', 'Joy', 'Sue', 'Kay', 'Lou', 'Belle', 'Rose']
            };
            
            const batchSize = 25; // Cosmos DB batch limit
            const records = [];
            
            // Generate records first
            for (let i = 1; i <= testCount; i++) {
              const penNumber = `PEN${String(i).padStart(6, '0')}`;
              const record = {
                id: generateUUID(),
                pen: penNumber,
                legalFirstName: names.first[i % names.first.length],
                legalMiddleNames: Math.random() > 0.3 ? names.middle[i % names.middle.length] : null,
                legalLastName: names.last[i % names.last.length],
                dob: new Date(1980 + (i % 40), (i % 12), (i % 28) + 1).toISOString().split('T')[0],
                localID: Math.random() > 0.5 ? `LOCAL${String(i).padStart(4, '0')}` : null,
                createdAt: new Date().toISOString(),
                testRecord: true,
                recordIndex: i
              };
              records.push(record);
            }
            
            // Insert records in batches
            console.log(`   Inserting ${records.length} records in batches of ${batchSize}...`);
            let insertedCount = 0;
            
            for (let i = 0; i < records.length; i += batchSize) {
              const batch = records.slice(i, i + batchSize);
              
              for (const record of batch) {
                try {
                  await container.items.create(record);
                  insertedCount++;
                  
                  if (insertedCount % 10 === 0 || insertedCount === records.length) {
                    console.log(`   Progress: ${insertedCount}/${records.length} records inserted`);
                  }
                } catch (error) {
                  if (error.code === 409) {
                    console.log(`   Skipping duplicate record: ${record.pen}`);
                  } else {
                    console.error(`   Failed to insert record ${record.pen}:`, error.message);
                  }
                }
              }
              
              // Small delay between batches to avoid throttling
              if (i + batchSize < records.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }
            
            // Final verification with detailed queries
            console.log('üîç Running verification queries...');
            
            // Count total test records
            const { resources: finalResults } = await container.items
              .query('SELECT * FROM c WHERE c.testRecord = true')
              .fetchAll();
            console.log(`‚úÖ Total test records: ${finalResults.length}`);
            
            // Test different query patterns
            const queries = [
              {
                name: 'Find by First Name',
                sql: "SELECT * FROM c WHERE c.legalFirstName = 'Alice' AND c.testRecord = true"
              },
              {
                name: 'Find by Last Name',
                sql: "SELECT * FROM c WHERE c.legalLastName = 'Smith' AND c.testRecord = true"
              },
              {
                name: 'Find by Date Range',
                sql: "SELECT * FROM c WHERE c.dob >= '1990-01-01' AND c.dob <= '1999-12-31' AND c.testRecord = true"
              },
              {
                name: 'Find records with Middle Names',
                sql: "SELECT * FROM c WHERE c.legalMiddleNames != null AND c.testRecord = true"
              },
              {
                name: 'Find records with Local ID',
                sql: "SELECT * FROM c WHERE c.localID != null AND c.testRecord = true"
              },
              {
                name: 'Count by Last Name',
                sql: "SELECT c.legalLastName, COUNT(1) as count FROM c WHERE c.testRecord = true GROUP BY c.legalLastName"
              }
            ];
            
            console.log('‚ö° Testing query performance...');
            for (const query of queries) {
              const startTime = Date.now();
              const { resources: results } = await container.items.query(query.sql).fetchAll();
              const queryTime = Date.now() - startTime;
              
              console.log(`   ${query.name}: ${results.length} results in ${queryTime}ms`);
              
              // Show sample result for some queries
              if (results.length > 0 && query.name === 'Count by Last Name') {
                console.log(`     Sample: ${JSON.stringify(results[0])}`);
              }
            }
            
            // Test pagination
            console.log('üìÑ Testing pagination...');
            const pageSize = 5;
            let pageCount = 0;
            let totalPaginated = 0;
            
            const iterator = container.items.query('SELECT * FROM c WHERE c.testRecord = true', {
              maxItemCount: pageSize
            }).getAsyncIterator();
            
            for await (const { resources: page } of iterator) {
              pageCount++;
              totalPaginated += page.length;
              console.log(`   Page ${pageCount}: ${page.length} items`);
              
              if (pageCount >= 3) { // Limit to first 3 pages for demo
                console.log(`   ... (stopping after ${pageCount} pages for demo)`);
                break;
              }
            }
            
            // Get container statistics
            console.log('üìä Getting container statistics...');
            try {
              const containerResponse = await container.read();
              console.log(`   Container throughput: ${containerResponse.resource.throughput || 'Shared'}`);
              console.log(`   Partition key: ${containerResponse.resource.partitionKey.paths.join(', ')}`);
              console.log(`   Indexing mode: ${containerResponse.resource.indexingPolicy.indexingMode}`);
            } catch (error) {
              console.log(`   Could not retrieve container statistics: ${error.message}`);
            }
            
            console.log('üéâ All tests completed successfully!');
            console.log(`üìà Summary:`);
            console.log(`   - Database: ${process.env.TEST_DATABASE_NAME}`);
            console.log(`   - Container: ${process.env.TEST_CONTAINER_NAME}`);
            console.log(`   - Records inserted: ${insertedCount}`);
            console.log(`   - Total test records: ${finalResults.length}`);
            
          } catch (error) {
            console.error('‚ùå Test failed:', error.message);
            console.error('Error details:', error);
            
            // Provide helpful error messages
            if (error.message.includes('firewall') || error.message.includes('blocked') || error.code === 403) {
              console.error('üí° This appears to be a firewall/network access issue.');
              console.error('üí° Solutions:');
              console.error('   1. Enable "Allow access from Azure services" in Cosmos DB networking');
              console.error('   2. Add GitHub Actions IP ranges to firewall');
              console.error('   3. Use a self-hosted runner in your VNet');
            } else if (error.message.includes('unauthorized') || error.code === 401) {
              console.error('üí° Authentication issue - check your connection string');
            } else if (error.message.includes('connection string')) {
              console.error('üí° Invalid connection string format');
            } else if (error.code === 429) {
              console.error('üí° Request rate too large - consider reducing batch size');
            } else if (error.code === 409) {
              console.error('üí° Conflict - resource may already exist');
            }
            
            process.exit(1);
          }
        }
        
        testCosmosDB();
        EOF
        
        TEST_DATA_COUNT="${{ github.event.inputs.test_data_count || '5' }}" node test-cosmos-complete.js

    - name: Cleanup Test Resources
      if: always()
      run: |
        echo "Cleaning up test resources..."
        
        cat > cleanup.js << 'EOF'
        const { CosmosClient } = require('@azure/cosmos');
        
        async function cleanup() {
          try {
            const client = new CosmosClient({
              connectionString: process.env.AZURE_COSMOSDB_CONNECTION_STRING,
              connectionPolicy: {
                requestTimeout: 30000
              }
            });
            
            console.log('üßπ Cleaning up test resources...');
            
            const database = client.database(process.env.TEST_DATABASE_NAME);
            
            // Try to delete container first
            try {
              const container = database.container(process.env.TEST_CONTAINER_NAME);
              await container.delete();
              console.log('‚úÖ Test container deleted successfully');
            } catch (error) {
              if (error.code === 404) {
                console.log('‚ÑπÔ∏è Test container was not found (may have been deleted already)');
              } else {
                console.log('‚ö†Ô∏è Container cleanup warning:', error.message);
              }
            }
            
            // Try to delete database
            try {
              await database.delete();
              console.log('‚úÖ Test database deleted successfully');
            } catch (error) {
              if (error.code === 404) {
                console.log('‚ÑπÔ∏è Test database was not found (may have been deleted already)');
              } else {
                console.log('‚ö†Ô∏è Database cleanup warning:', error.message);
              }
            }
            
            console.log('üéØ Cleanup completed');
            
          } catch (error) {
            console.log('‚ö†Ô∏è Cleanup completed with warnings:', error.message);
            // Don't fail the workflow on cleanup errors
          }
        }
        
        cleanup();
        EOF
        
        node cleanup.js